# ============================================================================
# 本地开发环境变量示例
# 
# 使用方法：
# 1. 复制此文件为 .dev.vars
# 2. 填入实际的配置值
# 3. .dev.vars 已被 .gitignore 忽略，不会提交到仓库
# ============================================================================

# ============================================================================
# 基础配置
# ============================================================================

# 开发模式（启用默认 UUID）
# 生产环境请设置为 false 或删除此变量
DEV_MODE=true

# API 访问密钥（保护 /api/* 端点）
# 用于访问 /api/uuids, /api/stats, /api/uuids/refresh 等端点
API_KEY=your-secure-api-key-here

# 默认 UUID（仅 DEV_MODE=true 时生效）
# 生产环境不需要此变量
UUID=d342d11e-d424-4583-b36e-524ab1f0afa4

# ============================================================================
# 可选配置
# ============================================================================

# 代理 IP（用于 TCP 连接重试）
# PROXY_IP=your-proxy-ip

# DNS 服务器地址（默认 Cloudflare DoH）
# DNS_SERVER=https://1.1.1.1/dns-query

# UUID 缓存时间（秒，默认 300）
UUID_CACHE_TTL=300

# 日志级别: OFF | ERROR | WARN | INFO | DEBUG
# 默认：开发模式 DEBUG，生产模式 WARN
# LOG_LEVEL=DEBUG

# ============================================================================
# 流量统计上报配置（可选）
# ============================================================================

# 流量上报端点 URL
# 配合 scripts/mock_node.py 使用，模拟 remnawave node 行为
# STATS_REPORT_URL=http://your-server:2222/worker/report

# 流量上报认证 Token（可选）
# STATS_REPORT_TOKEN=your-auth-token

# ============================================================================
# Remnawave API 配置
# ============================================================================

# Remnawave 面板 API 地址
# RW_API_URL=https://your-panel.example.com

# Remnawave API 密钥
# 在 Remnawave 面板设置中获取
# RW_API_KEY=your-api-key-here

# ============================================================================
# 分层缓存配置
# ============================================================================
#
# 缓存架构：
# - L1: Cache API（边缘节点，始终启用，最快）
# - L2: KV 或 D1（持久化，可选，用于跨边缘节点共享）
#
# 读取顺序：
# 1. 先查 L1 (Cache API)
# 2. L1 未命中 → 查 L2 (KV/D1)
# 3. L2 命中 → 回填 L1，返回数据
# 4. 全部未命中 → 请求原始 API
#
# 写入策略：
# - 始终写入 L1
# - L2 写入有间隔限制（默认 1 分钟），避免频繁写入
#
# 配置方法：
# 1. KV 和 D1 需要在 wrangler.jsonc 中绑定（不是环境变量）
# 2. 如果同时配置了 KV 和 D1，优先使用 KV 作为 L2
# 3. 如果都不配置，只使用 L1 (Cache API)
#
# KV 绑定（在 wrangler.jsonc 中添加）：
# "kv_namespaces": [
#   { "binding": "UUID_KV", "id": "<your-kv-namespace-id>" }
# ]
#
# D1 绑定（在 wrangler.jsonc 中添加）：
# "d1_databases": [
#   { "binding": "UUID_D1", "database_name": "uuid-cache", "database_id": "<your-d1-database-id>" }
# ]
#
# 创建 KV 命名空间：
#   wrangler kv namespace create UUID_KV
#
# 创建 D1 数据库：
#   wrangler d1 create uuid-cache
#
# 初始化 D1 表：
#   wrangler d1 execute uuid-cache --command="CREATE TABLE IF NOT EXISTS uuid_cache (key TEXT PRIMARY KEY, value TEXT NOT NULL, expires_at INTEGER NOT NULL, created_at INTEGER NOT NULL)"
#   wrangler d1 execute uuid-cache --command="CREATE INDEX IF NOT EXISTS idx_expires_at ON uuid_cache(expires_at)"
